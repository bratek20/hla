// DO NOT EDIT! Autogenerated by HLA tool

package pl.bratek20.hla.definitions.fixtures

import pl.bratek20.hla.facade.api.*
import pl.bratek20.hla.facade.fixtures.*

import pl.bratek20.hla.definitions.api.*

data class ExpectedKeyDefinition(
    var name: String? = null,
    var type: (ExpectedTypeDefinition.() -> Unit)? = null,
)
fun diffKeyDefinition(given: KeyDefinition, expectedInit: ExpectedKeyDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedKeyDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.type?.let {
        if (diffTypeDefinition(given.type, it) != "") { result.add(diffTypeDefinition(given.type, it, "${path}type.")) }
    }

    return result.joinToString("\n")
}

data class ExpectedEnumDefinition(
    var name: String? = null,
    var values: List<String>? = null,
)
fun diffEnumDefinition(given: EnumDefinition, expectedInit: ExpectedEnumDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedEnumDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.values?.let {
        if (given.values.size != it.size) { result.add("${path}values size ${given.values.size} != ${it.size}") }
        given.values.forEachIndexed { idx, entry -> if (entry != it[idx]) { result.add("${path}values[${idx}] ${entry} != ${it[idx]}") } }
    }

    return result.joinToString("\n")
}

data class ExpectedImplSubmoduleDefinition(
    var data: List<(ExpectedComplexStructureDefinition.() -> Unit)>? = null,
    var dataKeys: List<(ExpectedKeyDefinition.() -> Unit)>? = null,
)
fun diffImplSubmoduleDefinition(given: ImplSubmoduleDefinition, expectedInit: ExpectedImplSubmoduleDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedImplSubmoduleDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.data?.let {
        if (given.data.size != it.size) { result.add("${path}data size ${given.data.size} != ${it.size}") }
        given.data.forEachIndexed { idx, entry -> if (diffComplexStructureDefinition(entry, it[idx]) != "") { result.add(diffComplexStructureDefinition(entry, it[idx], "${path}data[${idx}].")) } }
    }

    expected.dataKeys?.let {
        if (given.dataKeys.size != it.size) { result.add("${path}dataKeys size ${given.dataKeys.size} != ${it.size}") }
        given.dataKeys.forEachIndexed { idx, entry -> if (diffKeyDefinition(entry, it[idx]) != "") { result.add(diffKeyDefinition(entry, it[idx], "${path}dataKeys[${idx}].")) } }
    }

    return result.joinToString("\n")
}

data class ExpectedModuleDefinition(
    var name: String? = null,
    var namedTypes: List<(ExpectedSimpleStructureDefinition.() -> Unit)>? = null,
    var valueObjects: List<(ExpectedComplexStructureDefinition.() -> Unit)>? = null,
    var interfaces: List<(ExpectedInterfaceDefinition.() -> Unit)>? = null,
    var properties: List<(ExpectedComplexStructureDefinition.() -> Unit)>? = null,
    var propertyKeys: List<(ExpectedKeyDefinition.() -> Unit)>? = null,
    var enums: List<(ExpectedEnumDefinition.() -> Unit)>? = null,
    var simpleCustomTypes: List<(ExpectedSimpleStructureDefinition.() -> Unit)>? = null,
    var complexCustomTypes: List<(ExpectedComplexStructureDefinition.() -> Unit)>? = null,
    var data: List<(ExpectedComplexStructureDefinition.() -> Unit)>? = null,
    var dataKeys: List<(ExpectedKeyDefinition.() -> Unit)>? = null,
    var implSubmodule: (ExpectedImplSubmoduleDefinition.() -> Unit)? = null,
)
fun diffModuleDefinition(given: ModuleDefinition, expectedInit: ExpectedModuleDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedModuleDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (diffModuleName(given.name, it) != "") { result.add(diffModuleName(given.name, it, "${path}name.")) }
    }

    expected.namedTypes?.let {
        if (given.namedTypes.size != it.size) { result.add("${path}namedTypes size ${given.namedTypes.size} != ${it.size}") }
        given.namedTypes.forEachIndexed { idx, entry -> if (diffSimpleStructureDefinition(entry, it[idx]) != "") { result.add(diffSimpleStructureDefinition(entry, it[idx], "${path}namedTypes[${idx}].")) } }
    }

    expected.valueObjects?.let {
        if (given.valueObjects.size != it.size) { result.add("${path}valueObjects size ${given.valueObjects.size} != ${it.size}") }
        given.valueObjects.forEachIndexed { idx, entry -> if (diffComplexStructureDefinition(entry, it[idx]) != "") { result.add(diffComplexStructureDefinition(entry, it[idx], "${path}valueObjects[${idx}].")) } }
    }

    expected.interfaces?.let {
        if (given.interfaces.size != it.size) { result.add("${path}interfaces size ${given.interfaces.size} != ${it.size}") }
        given.interfaces.forEachIndexed { idx, entry -> if (diffInterfaceDefinition(entry, it[idx]) != "") { result.add(diffInterfaceDefinition(entry, it[idx], "${path}interfaces[${idx}].")) } }
    }

    expected.properties?.let {
        if (given.properties.size != it.size) { result.add("${path}properties size ${given.properties.size} != ${it.size}") }
        given.properties.forEachIndexed { idx, entry -> if (diffComplexStructureDefinition(entry, it[idx]) != "") { result.add(diffComplexStructureDefinition(entry, it[idx], "${path}properties[${idx}].")) } }
    }

    expected.propertyKeys?.let {
        if (given.propertyKeys.size != it.size) { result.add("${path}propertyKeys size ${given.propertyKeys.size} != ${it.size}") }
        given.propertyKeys.forEachIndexed { idx, entry -> if (diffKeyDefinition(entry, it[idx]) != "") { result.add(diffKeyDefinition(entry, it[idx], "${path}propertyKeys[${idx}].")) } }
    }

    expected.enums?.let {
        if (given.enums.size != it.size) { result.add("${path}enums size ${given.enums.size} != ${it.size}") }
        given.enums.forEachIndexed { idx, entry -> if (diffEnumDefinition(entry, it[idx]) != "") { result.add(diffEnumDefinition(entry, it[idx], "${path}enums[${idx}].")) } }
    }

    expected.simpleCustomTypes?.let {
        if (given.simpleCustomTypes.size != it.size) { result.add("${path}simpleCustomTypes size ${given.simpleCustomTypes.size} != ${it.size}") }
        given.simpleCustomTypes.forEachIndexed { idx, entry -> if (diffSimpleStructureDefinition(entry, it[idx]) != "") { result.add(diffSimpleStructureDefinition(entry, it[idx], "${path}simpleCustomTypes[${idx}].")) } }
    }

    expected.complexCustomTypes?.let {
        if (given.complexCustomTypes.size != it.size) { result.add("${path}complexCustomTypes size ${given.complexCustomTypes.size} != ${it.size}") }
        given.complexCustomTypes.forEachIndexed { idx, entry -> if (diffComplexStructureDefinition(entry, it[idx]) != "") { result.add(diffComplexStructureDefinition(entry, it[idx], "${path}complexCustomTypes[${idx}].")) } }
    }

    expected.data?.let {
        if (given.data.size != it.size) { result.add("${path}data size ${given.data.size} != ${it.size}") }
        given.data.forEachIndexed { idx, entry -> if (diffComplexStructureDefinition(entry, it[idx]) != "") { result.add(diffComplexStructureDefinition(entry, it[idx], "${path}data[${idx}].")) } }
    }

    expected.dataKeys?.let {
        if (given.dataKeys.size != it.size) { result.add("${path}dataKeys size ${given.dataKeys.size} != ${it.size}") }
        given.dataKeys.forEachIndexed { idx, entry -> if (diffKeyDefinition(entry, it[idx]) != "") { result.add(diffKeyDefinition(entry, it[idx], "${path}dataKeys[${idx}].")) } }
    }

    expected.implSubmodule?.let {
        if (diffImplSubmoduleDefinition(given.implSubmodule, it) != "") { result.add(diffImplSubmoduleDefinition(given.implSubmodule, it, "${path}implSubmodule.")) }
    }

    return result.joinToString("\n")
}

data class ExpectedTypeDefinition(
    var name: String? = null,
    var wrappers: List<TypeWrapper>? = null,
)
fun diffTypeDefinition(given: TypeDefinition, expectedInit: ExpectedTypeDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedTypeDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.wrappers?.let {
        if (given.wrappers.size != it.size) { result.add("${path}wrappers size ${given.wrappers.size} != ${it.size}") }
        given.wrappers.forEachIndexed { idx, entry -> if (entry != it[idx]) { result.add("${path}wrappers[${idx}] ${entry} != ${it[idx]}") } }
    }

    return result.joinToString("\n")
}

data class ExpectedFieldDefinition(
    var name: String? = null,
    var type: (ExpectedTypeDefinition.() -> Unit)? = null,
    var attributes: List<(ExpectedAttribute.() -> Unit)>? = null,
    var defaultValue: String? = null,
)
fun diffFieldDefinition(given: FieldDefinition, expectedInit: ExpectedFieldDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedFieldDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.type?.let {
        if (diffTypeDefinition(given.type, it) != "") { result.add(diffTypeDefinition(given.type, it, "${path}type.")) }
    }

    expected.attributes?.let {
        if (given.attributes.size != it.size) { result.add("${path}attributes size ${given.attributes.size} != ${it.size}") }
        given.attributes.forEachIndexed { idx, entry -> if (diffAttribute(entry, it[idx]) != "") { result.add(diffAttribute(entry, it[idx], "${path}attributes[${idx}].")) } }
    }

    expected.defaultValue?.let {
        if (given.defaultValue!! != it) { result.add("${path}defaultValue ${given.defaultValue!!} != ${it}") }
    }

    return result.joinToString("\n")
}

data class ExpectedAttribute(
    var name: String? = null,
    var value: String? = null,
)
fun diffAttribute(given: Attribute, expectedInit: ExpectedAttribute.() -> Unit, path: String = ""): String {
    val expected = ExpectedAttribute().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.value?.let {
        if (given.value != it) { result.add("${path}value ${given.value} != ${it}") }
    }

    return result.joinToString("\n")
}

data class ExpectedSimpleStructureDefinition(
    var name: String? = null,
    var typeName: String? = null,
    var attributes: List<(ExpectedAttribute.() -> Unit)>? = null,
)
fun diffSimpleStructureDefinition(given: SimpleStructureDefinition, expectedInit: ExpectedSimpleStructureDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedSimpleStructureDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.typeName?.let {
        if (given.typeName != it) { result.add("${path}typeName ${given.typeName} != ${it}") }
    }

    expected.attributes?.let {
        if (given.attributes.size != it.size) { result.add("${path}attributes size ${given.attributes.size} != ${it.size}") }
        given.attributes.forEachIndexed { idx, entry -> if (diffAttribute(entry, it[idx]) != "") { result.add(diffAttribute(entry, it[idx], "${path}attributes[${idx}].")) } }
    }

    return result.joinToString("\n")
}

data class ExpectedComplexStructureDefinition(
    var name: String? = null,
    var fields: List<(ExpectedFieldDefinition.() -> Unit)>? = null,
)
fun diffComplexStructureDefinition(given: ComplexStructureDefinition, expectedInit: ExpectedComplexStructureDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedComplexStructureDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.fields?.let {
        if (given.fields.size != it.size) { result.add("${path}fields size ${given.fields.size} != ${it.size}") }
        given.fields.forEachIndexed { idx, entry -> if (diffFieldDefinition(entry, it[idx]) != "") { result.add(diffFieldDefinition(entry, it[idx], "${path}fields[${idx}].")) } }
    }

    return result.joinToString("\n")
}

data class ExpectedInterfaceDefinition(
    var name: String? = null,
    var methods: List<(ExpectedMethodDefinition.() -> Unit)>? = null,
)
fun diffInterfaceDefinition(given: InterfaceDefinition, expectedInit: ExpectedInterfaceDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedInterfaceDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.methods?.let {
        if (given.methods.size != it.size) { result.add("${path}methods size ${given.methods.size} != ${it.size}") }
        given.methods.forEachIndexed { idx, entry -> if (diffMethodDefinition(entry, it[idx]) != "") { result.add(diffMethodDefinition(entry, it[idx], "${path}methods[${idx}].")) } }
    }

    return result.joinToString("\n")
}

data class ExpectedArgumentDefinition(
    var name: String? = null,
    var type: (ExpectedTypeDefinition.() -> Unit)? = null,
)
fun diffArgumentDefinition(given: ArgumentDefinition, expectedInit: ExpectedArgumentDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedArgumentDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.type?.let {
        if (diffTypeDefinition(given.type, it) != "") { result.add(diffTypeDefinition(given.type, it, "${path}type.")) }
    }

    return result.joinToString("\n")
}

data class ExpectedExceptionDefinition(
    var name: String? = null,
)
fun diffExceptionDefinition(given: ExceptionDefinition, expectedInit: ExpectedExceptionDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedExceptionDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    return result.joinToString("\n")
}

data class ExpectedMethodDefinition(
    var name: String? = null,
    var returnType: (ExpectedTypeDefinition.() -> Unit)? = null,
    var args: List<(ExpectedArgumentDefinition.() -> Unit)>? = null,
    var throws: List<(ExpectedExceptionDefinition.() -> Unit)>? = null,
)
fun diffMethodDefinition(given: MethodDefinition, expectedInit: ExpectedMethodDefinition.() -> Unit, path: String = ""): String {
    val expected = ExpectedMethodDefinition().apply(expectedInit)
    val result: MutableList<String> = mutableListOf()

    expected.name?.let {
        if (given.name != it) { result.add("${path}name ${given.name} != ${it}") }
    }

    expected.returnType?.let {
        if (diffTypeDefinition(given.returnType, it) != "") { result.add(diffTypeDefinition(given.returnType, it, "${path}returnType.")) }
    }

    expected.args?.let {
        if (given.args.size != it.size) { result.add("${path}args size ${given.args.size} != ${it.size}") }
        given.args.forEachIndexed { idx, entry -> if (diffArgumentDefinition(entry, it[idx]) != "") { result.add(diffArgumentDefinition(entry, it[idx], "${path}args[${idx}].")) } }
    }

    expected.throws?.let {
        if (given.throws.size != it.size) { result.add("${path}throws size ${given.throws.size} != ${it.size}") }
        given.throws.forEachIndexed { idx, entry -> if (diffExceptionDefinition(entry, it[idx]) != "") { result.add(diffExceptionDefinition(entry, it[idx], "${path}throws[${idx}].")) } }
    }

    return result.joinToString("\n")
}